# Graph

当一个图中结点规模很庞大的时候，采用邻近矩阵来存储图显然是不太可行的。而在现实的社交网络中，结点的规模往往是上百万甚至上千万级别的，
这个时候就需要新的数据结构来存储图的信息，在Python中有一个用于图的存储和计算的包` networkx `，功能十分强大，但也不可否认，整体性能不高，
运行速度慢，毕竟作为一个第三方的包，考虑东西自然多很多，但不是所有的考虑在我们使用时都是必要的。` Graph `是我自定义的一个精简版的图的
存储结构，丢掉了很多不必要的判断，因此使用时需要注意
***  
### 1.1 存储   
` Graph ` 类中有两个` dict ` 类型的变量` nodes ` 和 ` edges `   

#### 1.1.1 ` nodes `   
` nodes ` 中以图中的每个结点作为key，该结点的邻居结点作为value，这里value的类型为 ` set `，使用` set `有两个原因，一是为了避免存储
重复的元素，二是为了提高后面查询的效率    
```python
>>> graph = Graph()
>>> # 省略构图操作
>>> graph.nodes   
{1: {2, 3, 4}, 2: {1, 4}, 3: {1}, 4: {1, 2}}
>>> graph.get_nodes()  
[1, 2, 3, 4]
```   
#### 1.1.2 ` edges `   
` edges ` 中 key为 ` tuple `类型，如 ` (i, j) `，表示的是结点i，j之间的边，value为边(i, j)的权重。在无向图中，(i, j), (j, i)被
视为一条边，只存储一个   
```python
>>> graph.edges   
{(1, 2): 1.0, (1, 3): 1.0, (1, 4): 1.0, (2, 4): 1.0}
>>> graph.get_edges()  
[(1, 2), (1, 3), (1, 4), (2, 4)]
```   
#### 1.1.3 存储结构性能说明  
在Python中` dict `， ` set `，` list `，` tuple `是四种最典型的也是最常用的数据结构, 在 ` Graph `的实现中主要用到了` dict `， ` set `
进行数据存储。在内存消耗方面，` dict `， ` set `，` list `，` tuple `内存消耗依次减小，其中` dict ` 最占用内存，但相比与邻接矩阵，
采用这种方式还是可行的，因为 ` edges ` 中只存储了有边的信息。在查找性能方面，由于` dict ` 和 ` set `底层采用了哈希表的实现方式，所以
查找的时间复杂度是常数时间复杂度O(1)，而` list ` 和 ` tuple ` 的查找的时间复杂度是线性时间复杂度O(n)，在n的规模较大时，查找的性能差
别还是很明显的。而且，构图是一次性操作，后续图的处理和计算过程中会反复的执行查找操作，因此在不考虑内存消耗的情况下，采用` dict ` 和 `
 set `性能更高
